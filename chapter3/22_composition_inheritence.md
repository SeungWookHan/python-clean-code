## 컴포지션과 상속
객체 지향 소프트웨어를 디자인할 때  
1. 다형성  
2. 상속  
3. 캡슐화  
같은 주요 개념을 어떻게 사용하고 문제를 어떻게 해결할 것인지에 대한 논쟁이 있어왔다.  
일반적으로 사용되는 개념은 상속일 것이다.  
개발자는 종종 필요한 클래스들의 계층 구조를 만들고 각 클래스가 구현해야하는 메서드를 결정하는 것으로부터 개발을 시작한다.  

반면 상속에는 위험도 있다.  
가장 주된 위험은 부모 클래스를 확장하여 새로운 클래스를 만들때마다  
**부모와 강력하게 결합된 새로운 클래스**가 생긴다는 점이다.  
소프트웨어를 설계할 때는 **결합력(coupling)**을 최소한으로 줄이는 것이 중요하다.  

상속과 관련해 가장 많이 사용하는 기능은 코드 재사용인데,  
단지 부모 클래스에 있는 메서드를 공짜로 얻을 수 있다는 점만으로 상속을 하는 것은 좋지 않은 생각이다.  
코드를 재사용하는 올바른 방법은  
1. 여러 상황에서 동작 가능
2. 쉽게 조합할 수 있는  
응집력 높은 객체를 사용하는 것이다.  
---
### 상속이 좋은 선택인 경우  
파생 클래스를 만드는 것은 양날의 검이라고 한다.  
부모 클래스의 메서드를 공짜로 얻을 수 있는 장점이 있지만  
반면 모든 것을 새로운 클래스에 가져왔기 때문에 새로운 정의에 너무 많은 기능을 추가하게 되는 단점이 있다고 한다.  
새로운 하위 클래스를 만들 때 상속된 모든 메서드를 실제로 사용할 것인지 생각해보는 것이 좋다고 한다.  
- 상위 클래스는 잘 정의된 인터페이스 대신 막연한 정의와 너무 많은 책임을 가졌다.  
- 하위 클래스는 확장하려고 하는 상위 클래스의 적절한 세분화가 아니다.  
위와 같은 경우가 나오면 설계상의 실수라고 한다.  

상속을 잘 사용한 좋은 예는 이와 같다고 한다.  
public 메서드와 속성 인터페이스를 정의한 컴포넌트 -> 이 클래스의 기능을 그대로 물려받으면서 추가 기능을 더하려는 경우 또는 특정 기능을 수정하려는 경우  

예시로 들어준 것은 파이썬 표준 라이브러리에서  
https.server 패키지에서 BaseHTTPRequestHandler 기본 클래스와  
이 기본 인터페이스의 일부를 추가하거나 변경하여 확장하는 SimpleHTTPRequestHandler 하위 클래가 있다고 한다.  

인터페이스 정의 역시 상속의 또 다른 좋은 예라고 한다.  
어떤 객체에 인터페이스 방식을 강제하고자 할 때  
1. 구현을 하지 않은 기본 추상 클래스 생성  
2. 이 클래스를 상속하는 하위 클래스에서 적절한 구현  

마지막 상속의 또 다른 사용 예는 예외라고 한다.  
파이썬의 표준 예외는 Exception에서 파생되는데,  
이것은 except Exception: 같은 문구를 통해 모든 에러를 캐치할 수 있게 해주기 때문이다.  
모든 예외가 Exception에서 상속받은 클래스이기 때문이다.  
이는 requests 라이브러리에서도 잘 동작하는데, 예를 들어 HTTPError는 RequestException을 상속받고,  
RequestException은 IOError를 상속받는다고 한다.  
---
### 상속 안티패턴
부모 클래스는 새 파생 클래스의 공통 정의의 일부가 된다.  
상속된 메서드가 새로운 클래스의 일부가 되기 때문이다.  
클래스의 public 메서드는 부모 클래스가 정의하는 것과 일치해야 한다.  
```
class TransactionPolicy(collections.UserDict):
    """ 잘못된 상속의 예 """

    def change_in_policy(self, customer_id, **new_policy_data):
        self[customer_id].update(**new_policy_data)
```
여러 고객에게 정책을 적용하는 기능을 가진 보험 관리 시스템을 생각해보자.  
동시에 변경사항을 적용하거나 저장하기 위해 고객 정보를 메모리에 보관해야 한다.  
필요로 하는 기본 기능은 새 고객 정보를 기록하고 정책을 변경하거나 일부 데이터를 편집하는 것이다.  
또한 배치 작업을 지원해야 한다.  
정책 자체가 변경되면 현재 트랜잭션의 고객 모두에게 정책을 적용해야 한다.  
필요한 데이터 구조를 생각해보면 특정 고객의 레코드에 상수 시간에 접근할 수 있어야 한다.  
따라서 policy_transaction[customer_id]처럼 구현하는 것이 멋진 인터페이스처럼 보인다.  
이것은 첨자형 객체, 더 나아가 딕셔너리 타입을 생각할 수 있다.  

위 디자인에는 적어도 두가지의 주요 문제점이 있다고 한다.  
첫째, 계층 구조가 잘못됨  
기본 클래스에서 새 클래스를 만드는 것은 말 그대로 그것이 개념적으로 확장되고 세부적인 것이라는 것을 의미한다.  
하지만 TransactionPolicy라는 이름만 봐서는 딕셔너리 타입이라는 것을 바로 알 수 없을 것이다.  
사용자가 객체의 public 인터페이스를 통해 노출된 public 메서드들을 확인하게 되면 특이하게 전문화된 이상한 계층구조라고 느끼게 될 것이다.  

둘째, 결합력(coupling)에 대한 문제  
TransactionPolicy는 딕셔너리의 모든 메서드를 포함한다.  
하지만 pop(), items() 같은 메서드는 실제 필요하지 않을 것이다.  
(그럼에도 그런 메서드가 포함되어 있음)  
이것들은 public 메서드이므로 사용자는 이 메서드들을 호출할 수 있는 가능성이 생겨버린다.  
또한 딕셔너리 타입을 상속받아 확장함으로써 얻는 이득도 별로 없다.  
현재 정책에 영향을 받는 모든 고객을 업데이트 하는 메서드가 유일한 추가 메서드로써 부모 클래스와는 상관이 없다.  

이것이 바로 구현 객체를 도메인 객체와 혼합할때 발생하는 문제라고 한다.  
딕셔너리는 특정 유형의 작업에 적합한 객체 또는 데이터 구조로서 다른 데이터 구조와 마찬가지로 트레이드오프가 있다.  
TransactionPolicy는 특정 도메인의 정보를 나타내는 것이므로 해결하려는 문제의 일부분에 사용되는 엔티티여야만 한다.  

이러한 계층 구조는 올바르지 않으며 단지 첨자 기능을 얻기 위해 딕셔너리를 상속받아 확장하는 것은 정당화가 되지 않는다.  
**온전히 기본 클래스에 추가되는 그리고 보다 특화된 것을 구현할 때에만 확장을 해야 한다.**  
동일한 규칙이 도메인 내에서의 클래스에도 적용된다.  

올바른 해결책은 **컴포지션**을 사용하는 것이라고 한다.  
TransactionPolicy 자체가 딕셔너리가 되는 것이 아닌 딕셔너리를 활용하는 것이다.  
딕셔너리를 private 속성에 저장하고  
__getitem__()으로 딕셔너리의 프록시를 만들고 나머지 필요한 public 메서드를 추가적으로 구현하는 것이다.  
```
class TransactionPolicy:
    """ 컴포지션을 사용한 리팩토링 예제 """
    def __init__(self, policy_data, **extra_data):
        self._data = {**policy_data, **extra_data}
    
    def change_in_policy(self, customer_id, **new_policy_data):
        self._data[customer_id].update(**new_policy_data)

    def __getitem__(self, customer_id):
        return self._data[customer_id]
    
    def __len__(self):
        return len(self._data)
```  
위 방법은 개념적으로 정확할뿐만 아니라 확장성도 뛰어나다.  
현재 딕셔너리인 데이터 구조를 향후 변경하려고 해도 인터페이스만 유지하면 사용자는 영향을 받지 않는다.  
이는 결합력을 줄이고,  
파급효과를 최소화하며  
보다 나은 리팩토링을 허용하고 코드를 유지 관리하기 쉽게 만든다.  
(단위 테스트를 변경하지 않아도 됨)  

---
### 파이썬의 다중상속
파이썬은 다중상속을 지원한다.  
부적절한 상속은 디자인 문제를 유발하는데, 특히 다중상속을 잘못 사용하면 더 큰 문제를 초래할 수 있다고 한다.  

어떤 경우에는 다중상속이 매우 유익할 수도 있다.  
하지만 올바르게 사용될 때에만 유효한 해결책이 될 수 있으므로  
새로운 패턴(어댑터 패턴)과 믹스인(mixin)을 사용한 예시를 든다.  

다중상속을 사용한 가장 강력한 앱의 하나가 믹스인을 활용한 앱이라고 한다.  
그전에 다중상속에 대해 알아본다.  

#### 메서드 결정 순서(MRO)
다이아몬드 문제: 4개의 클래스가 다이아몬드 형태로 다중 상속을 받은 상황에서 손자 클래스 입장에서 두개의 부모 클래스가 같은 이름의 메서드를 가진 경우 어떤 메서드를 사용해야 할지 모호해지는 문제  

두개 이상의 클래스를 확장하고, 해당 클래스들이 모두 하나의 같은 기본 클래스를 확장한 경우 맨 아래 클래스가 최상위 클래스에서 오는 메서드를 해결하는 방법은 여러가지가 있다.  
```
class BaseModule:
    module_name = "top"

    def __init__(self, module_name):
        self.name = module_name
    
    def __str__(self):
        return f"{self.module_name}:{self.name}"
    
class BaseModule1(BaseModule):
    module_name = "module-1"

class BaseModule2(BaseModule):
    module_name = "module-2"

class BaseModule3(BaseModule):
    module_name = "module-3"

class ConcreteModelA12(BaseModule1, BaseModule2):
    """ 1과 2 확장 """

class ConcreteModelA23(BaseModule2, BaseModule3):
    """ 2와 3 확장 """


str(ConcreteModuleA12("test"))
# module-1:test
```  
이와 같이 충돌이 발생하진 않는다.  
파이썬은 C3 linearization 또는 MRO라는 알고리즘을 사용하여 이 문제를 해결한다고 한다.  
구체적으로 클래스에게 결정 순서를 직접 물어볼 수도 있다고 한다.  
```
[cls.__name__ for cls in ConcreteModuleA12.mor()]  
# ['ConcreteModuleA12', 'BaseModule1', 'BaseModule2', 'BaseModule', 'object']
```
---
#### 믹스인(mixin)
믹스인은 코드를 재사용하기 위해 일반적인 행동을 캡슐화해놓은 기본 클래스이다.  
대부분이 클래스에 정의된 메서드나 속성에 의존하기 때문에 그 자체로는 유용하지 않다고 한다.  
보통은 다른 클래스와 함께 믹스인 클래스를 다중 상속하여 믹스인에 있는 메서드나 속성을 사용한다.  
```
# 문자열을 받아서 하이픈(-)으로 구분된 값을 반환하는 파서  
class BaseTokenizer:
    def __init__(self, str_token):
        self.str_token = str_token
    
    def __iter__(self):
        yield from self.str_token.splie("-")
```  
이는 매우 직관적이라고 하는데......  
```
tk = BaseTokenizer("aaa-bbb-ccc-ddd")  
list(tk)  
# ['aaa', 'bbb', 'ccc', 'ddd']
```  
이제 기본 클래스를 변경하지 않고 값을 대문자로 변환해보자.  
이것은 간단한 예제이기에 새로운 클래스를 만들수도 있지만 많은 클래스가 이미 BaseTokenizer를 상속받아 확장했고 모든 클래스를 바꾸고 싶지는 않다고 가정한다.  
```
class UpperIterableMixin:
    def __iter__(self):
        return map(str.upper, super().__iter__())

class Tokenizer(UpperIterableMixin, BaseTokenizer):
    pass
```  
새로운 Tokenizer 클래스는 믹스인을 이용하기 때문에 새로운 코드가 필요 없다.  
이러한 유형의 혼합은 일종의 데코레이터 역할을 한다고 한다.  
Tokenizer는 믹스인에서 __iter__을 호출하고 다시 super() 호출을 통해 다음 클래스 BaseTokenizer에 위임한다.  
이때 이미 대문자가 전달되기 때문에 원하는 바 얻을 수 있다고 한다.  