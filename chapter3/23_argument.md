## 함수와 메서드의 인자

파이썬은 여러 가지 방법으로 인자를 받도록 함수를 정의할 수 있음  
또한 소프트웨어 엔지니어링에서 함수의 인자를 정의하는 것과 관련한 관행이 있음

### 파이썬의 함수 인자 동작방식

#### 인자는 어떻게 함수에 복사되는가?

파이썬의 첫 번째 규칙은 모든 인자가 값에 의해 전달(passed by a value)된다는 것이다.  
함수에 값을 전달하면 함수의 서명에 있는 변수에 할당하고 나중에 사용한다.  
인자를 변경하는 함수는 인자의 타입에 따라 다른 결과를 낼 수 있다.  
만약 mutable(변형 가능한) 객체를 전달하고 함수에서 해당 값을 변경하면 실제 값이 변경되는 부작용이 생길 수 있다.

```
def function(arg):
    arg += " in function"
    print(arg)

immutable = "hello"
function(immutable)
# hello in function
immutable
# hello

mutable = list("hello")
function(mutable)
# ['h', 'e', ..., 'f', 'u', ..., 'n']
mutable
# ['h', 'e', ..., 'f', 'u', ..., 'n']
```

첫 번째 예시인 문자열을 전달하면 함수의 인자에 할당한다.  
string 객체는 immutable(불변형) 타입이므로 "arg += in function" 문장은 새로운 객체를 만들어서 arg에 다시 할당한다.  
이 시점에서 arg는 단지 함수 스코프 내에 있는 로컬 변수이며 원래 변수와는 아무 관련이 없다.

반면 mutable 객체는 list를 전달하면 해당 문장은 list의 extend()를 호출하는 것과 같다.  
원래 리스트 객체에 대한 참조를 보유하고 있기에 함수 외부에 있는 실제 값이 변경된다.  
그렇기에 이러한 방식으로 변경하는 것은 가급적 피하고 다른 대안을 찾아야 한다고 한다.  
(절대적으로 옳은 상황이 아니라면....)  
`함수 인자를 변경하지 않아야 함. 최대한 함수에서 발생할 수 있는 부작용을 회피해야 함`

파이썬의 인자는 다른 프로그래밍 언어와 마찬가지로

- 위치에 기반을 두어 호출
- 키워드에 기반을 두어 호출
  두가지가 가능하다.  
  키워드 인자에 의한 호출은 오로지 명시적으로 파라미터를 지정해야 한다는 것을 의미한다.  
  또한 유일한 주의 사항은 이후의 파라미터도 반드시 키워드 인자 방식으로 호출돼야 한다는 점이다.  
  (그렇지 않으면 SyntaxError 발생)

---

#### 가변인자

파이썬은 다른 언어와 마찬가지로 가변 인자를 사용 가능하다.  
가변 인자 함수를 위한 몇 가지 권장사항과 기본 원칙을 배우고자 한다.  
가변 인자를 사용하려면 해당 인자를 패킹할 변수 앞에 별표(\*)를 사용한다.  
각 인자 요소에 list[0], list[1] ... 으로 전달하는 것은 전혀 파이썬스러운 코드가 아니라고 한다.

```
def f(first, second, third):
    print(first)
    print(second)
    print(third)

l = [1, 2, 3]
f(*l)
# 1
# 2
# 3
```

패킹 기업의 장점은 다른 방향으로도? 동작한다는 것이다.  
리스트 값을 각 위치별로 변수에 언패킹하려면 다음과 같이 할 수 있다.

```
a, b, c = [1, 2, 3]
```

부분적인 언패킹도 가능하다.  
시퀀스(or 리스트 or 튜플)의 첫 번째 값과 나머지에만 관심이 있다고 가정해보자.  
이런 경우 첫번째를 필요한 변수를 할당하고 나머지는 리스트로 패킹할 수 있다고 한다.  
언패킹하는 순서는 제한이 없고,  
언패킹할 부분이 없다면 결과는 비어있게 된다고 한다.

```
# 제너레이터와 언패킹 예제
def show(e, rest):
    print("요소: {0} - 나머지: {1}".format(e, rest))

first, *rest = [1, 2, 3, 4, 5]
show(first, rest)
# 요소: 1 - 나머지 [2, 3, 4, 5]

*rest, last = range(6)
show(last, rest)
# 요소 5 - 나머지: [0, 1, 2, 3, 4]

first, *middle, last = range(6)
first
# 0
middle
# [1, 2, 3, 4]
last
# 5

first, last, *empty = (1, 2)
first
# 1
last
# 2
empty
# []
```

변수 언패킹의 가장 좋은 사용 예는 반복이다.

1. 일련의 요소를 반복해야 하고
2. 각 요소가 차례로 있다면  
   각 요소를 반복할 때 언패킹하는 것이 좋다고 한다.

다음은 데이터를 받아서 사용자를 생성하는 예제이다.

```
USERS = [(i, f"first_name_{i}", "last_name_{i} ") for i in range(1_000)]

class User:
    def __init__(self, user_id, first_name, last_name):
        self.user_id = user_id
        self.first_name = first_name
        self.last_name = last_name

    def bad_users_from_rows(dbrows) -> list:
        """ DB 레코드에서 사용자를 생성하는 파이썬스럽지 않은 잘못된 예 """
        return [User(row[0], row[1], row[2]) for row in dbrows]

    def users_from_rows(dbrows) -> list:
        """ DB 레코드에서 사용자 생성 파이썬스러운 예 """
        return [
            User(user_id, first_name, last_name)
            for (user_id, first_name, last_name) in dbrows
        ]

```

두 번째 버전이 훨씬 가독성이 좋다.
첫 번째 버전인 bad_users_from_rows 함수에서는 row[0], row[1], row[2]가 무엇을 뜻하는지 전혀 알 수가 없다.  
반면 user_id, first_name, last_name는 직관적이다.  
자체 함수를 디자인할때 이러한 종류의 기능을 활용할 수 있다.

표준 라이브러리에서의 예는 max 함수에서 발견할 수 있다.

```
max(...)
    max(iterable, *[, default=obj, key=func]) -> value
    max(arg1, arg2, *args, *[, key=func]) -> value
    단일 반복형 인자를 넘기면 그 중에 가장 큰 값을 반환.
    키워드 인자로만 사용할 수 있는 default는 제공된 반복형이 비엇을 때 반환할 값이다.
    2개 이상의 인자가 사용되면 가장 큰 인자를 반환한다.
```

비슷한 표기법으로 이중 별표(\*\*)를 키워드 인자에 사용할 수 있다.  
딕셔너리에 이중 별표를 사용하여 함수에 전달하면 파라미터의 이름으로 키를 사용하고, 파라미터의 값으로 딕셔너리 값을 사용한다.

```
function(**{"key": "value})
이것은 아래와 동일하다.
function(key="value")

반대로 이중 별표로 시작하는 파라미터를 함수에 사용하면 반대 현상이 벌어진다.
키워드 제공 인자들이 딕셔너리로 패킹된다.

def function(**kwargs):
    print(kwargs)

function(key="value")
# {'key': 'value}
```

---

#### 함수 인자의 개수

너무 많은 인자를 사용하는 함수나 메서드가 왜 나쁜 디자인인지 살펴본다.  
이후 이 문제를 해결할 방법을 저자는 제안한다.

첫 번째 대안은 일반적인 소프트웨어 디자인의 원칙을 사용하는 것이다.  
즉, 구체화(reflection)함으로써 모든 인자를 포함하는 새로운 객체를 만드는 것이다.  
여러 인자를 새로운 객체로 압축하는 것은 모든 프로그래밍 언어에서 적용할 수 있는 방법이다.

또 다른 옵션은 파이썬의 특정 기능을 사용하는 것이다.  
가변 인자나 키워드 인자를 사용하여 동적 서명을 가진 함수를 만든다.  
파이썬스러운 방법이기는 하지만 매우 동적이어서 유지보수하기 어렵다는 점에서 주의해야 한다.  
만약 파라미터의 값에 대응하여 너무 많은 것들을 함수에서 처리하고 있다면 여러 작은 함수로 분리를 하라는 사인이다.  
**함수는 오직 한 가지 일만 해야 한다.**

---

#### 함수 인자의 결합력

함수 서명의 인수가 많을수록 호출자 함수와 밀접하게 결합될 가능성이 커진다.  
f1, f2 두 함수가 있고 f2가 더 많은 파라미터를 사용할수록 호출자는 정상 동작을 위한 모든 정보를 수집하는 것이  
점점 더 어려워질 것이다.

f1이 f2 호출을 위한 모든 정보를 가지고 있다고 해보자.  
첫째, f2는 아마도 추상화가 부족했을 것이다.  
f1은 f2가 필요로 하는 모든 것을 알고 있기 때문에 f2 내부적으로 무엇을 하는지 알아낼 수 있으며 거의 자체적 수행이 가능하다.  
(이는 f2가 그렇게 많은 것을 추상화하지 않았다는 방증)

둘째, f2는 다른 환경에서 사용하기가 어려워 f1에서만 유용하기에 재사용성이 떨어진다.

**함수가 보다 일반적인 인터페이스를 제공하고 더 높은 수준의 추상화로 작업할 수 있다면 코드 재사용성이 높아짐**  
이것은 클래스이 **init** 메서드를 포함하여 모든 종류의 함수와 객체 메서드에 적용된다.  
이와 같은 메서드가 있다는 것은 일반적으로 새로운 상위 레벨에 추상화 객체를 필요로 하거나 누락된 객체가 있음을 의미한다.  
(아무래도 f1, f2의 예를 말하는 것 같음)
pylint와 같은 정적 분석 도구를 사용하면 경고를 표시하는 문제인데, 이러한 경고를 만나면 무시하지 말고 리팩토링 해야함..

---

#### 많은 인자를 취하는 작은 함수의 서명

너무 많은 파라미터를 사용하는 함수를 찾았고 리팩토링을 해야할때는 어떻게 해야할까?  
만약 공통 객체에 파라미터 대부분이 포함되어 있다면 가장 쉽게 수정할 수 있다.

```
track_request(request.headers, request.ip_addr, request.request_id)
```

여기에 파라미터가 추가될수도 있지만 그렇지 않을 수도 있다.  
그러나 분명 모든 파라미터가 request와 관련이 있다는 것이다.  
그렇다면 그냥 request를 파라미터로 전달하는 것이 어떨까?!  
이는 간단한 변경사항이지만 코드를 크게 향상시킨다.

```
track_request(request)
```

의미적으로도 보다 이치에 맞는다.  
하지만 역시 mutable(변경 가능한) 객체를 전달할 때에는 부작용에 주의해야 한다.  
**함수는 전달받은 객체를 변경해서는 안된다**  
**부작용이 발생할 수 있기 때문이다.**  
실제로 객체의 무언가를 바꾸고 싶다면 전달된 값을 복사한 다음 새로운 수정본을 반환하는 것이 나은 대안이라고 한다.

**immutable 객체를 사용하여 부작용 최소화하기**

파라미터 그룹핑 이라는 방법도 있다.  
이전 예제에서 파라미터는 이미 그룹화되었기에 따로 그룹을 사용하지는 않은 예이다.  
그러나 분명하지 않은 경우에는 컨테이너처럼 하나의 객체에 파라미터를 그룹핑할 수 있고 이는 타당한 방법이다.  
구체화(reify)를 함으로써 디자인에서 누락되었던 추상화 작업을 하는 것이다.

또한 이전 방법들이 안 통한다면 최후의 수단으로 함수의 서명을 변경하여 다양한 인자를 허용할 수 있다.  
인자가 많은데 \*args, \*\*kwargs를 사용하면 가독성이나 이해가 더 어려운 상황을 만들 수 있다.

이런 경우 인터페이스에 대한 문서화 및 정확하게 사용됐는지 확실히 해야 한다.  
(그러나 때로는 이렇게 하는 것이 의미가 있는 경우가 있다고 한다. )

```
*args, **kwargs
장점: 정의된 함수가 실제로 융통성 있고 적응력 좋음
단점: 서명을 잃어버리고 가독성을 상실함
```

변수의 이름(함수의 인자 포함)이 코드를 훨씬 읽기 쉽게 만든다.  
위치(position) 인자든,  
키워드 인자든,  
가변 인자를 사용하면 매우 좋은 docstring 작성이 필수라고 한다.  
(이렇게 안하면 나중에 함수에 사용된 파라미터를 보고도 정확한 동학 파악 불가능)
