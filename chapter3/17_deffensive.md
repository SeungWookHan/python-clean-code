## 방어적 프로그래밍

방어적 프로그래밍은 이전의 DbC와는 다른 접근 방식을 따른다.  
계약에서 예외 발생, 실패 조건 기술 대신  
객체, 함수, 메서드와 같은 코드의 모든 부분을 유효하지 않은 것으로부터 스스로 보호할 수 있게 하는 것이라고 한다.

특히 다른 디자인 원칙과 결합될 경우 유용하다고 한다.(보완관계)

방어적 프로그래밍의 주요 주제

1. 예상할 수 있는 시나리오의 오류 처리
2. 발생하지 않아야 하는 오류 처리
   전자는 에러 핸들링 프로시저  
   후자는 assertion에 대한 것이라고 한다.

### 에러 핸들링

오류가 발생하기 쉬운 상황에서 에러 핸들링 프로시저를 사용하는데 데이터 입력시 자주 사용된다고 한다.

주요 목적

1. 예상되는 에러에 대해 실행을 계속할 수 있을지
2. 극복할 수 없는 오류여서 프로그램을 중단시킬지 결정

```
에러 처리 방법의 일부
- 값 대체(substitution)
- 에러 로깅
- 예외 처리
```

#### 값 대체

오류가 있어 소프트웨어가 잘못된 값을 생성하거나 종료될 위험이 있을 경우 결과 값을 다른 값으로 대체하는 것  
잘못된 결과 -> 정합성을 깨지 않는 다른 값으로 대체  
(기본값 또는 상수, 초기 값으로 바꿈)

하지만 값 대체가 항상 가능하지 않다고 한다.  
대체 값이 안전한 옵션인 경우에 한해 진행해야 한다.

값 대체 = 견고성과 정확성 간의 트레이드오프  
`소프트웨어 프로그램은 예상치 못한 상황에서도 실패하지 않아야 견고한 것이다. 하지만 무조건 실패하지 않는 것이 옳은 것은 아니다`

애플리케이션이 민감하고 중요한 정보를 다루는 경우 부정확한 결과를 그대로 내보낼 수 없다.  
이런 경우는 잘못된 결과로 프로그램을 폭파하는 것보다는 정확성을 선택해야 함

다른 방향으로 안전한 방법은

- 제공되지 않은 데이터에 기본 값을 사용하는 것

1. 설정되지 않은 환경 변수의 기본 값
2. 설정 파일의 누락된 항목
3. 함수의 파라미터
   같은 것은 기본 값으로 동작 가능한 것이다.

예를 들어 딕셔너리 자료형의 get메서드의 두번째 파라미터를 사용하는 것

```
configuration = {"dbport": 5432}
configuration.get("dbhost", "localhost")
# 'localhost'
configuration.get("dbport")
# 5432
```

환경변수에도 유사한 API가 있다고 한다.

```
import os
os.getenv("DBHOST")
# 'localhost'
os.getenv("DBPORT", 5432)
# 5432
```

위 두 예제에서 두번째 파라미터 없다면 None을 반환한다.  
None이 함수에서 정한 기본 값이기 때문이다.

```
def connenct_database(host="localhost", port=5432):
    logger.info("다음 정보로 데이터베이스에 접속: %s%i", host, port)
```

사용자 정의함수에서는 이와 같이 기본 값을 정의할 수 있다.

일반적으로 누락된 파라미터를 기본 값으로 바꿔도 문제 없지만,  
오류가 있는 데이터를 유사한 값으로 대체하는 것은 일부 오류를 숨겨버릴 수 있기에 위험하다고 한다.  
이러한 기준을 고려해서 `값 대체` 방법을 사용해야 한다.

---

#### 예외 처리

어떤 경우에는 계속 실행하는 것보다 차라리 실행을 멈추는 것이 좋다.  
DbC에서 보았듯이 사전조건 검증에 실패한 경우인데 이런 경우는 호출자에게 실패했음을 알리는 것이 좋다고 한다.

하지만 입력이 잘못되었을 때만 함수에 문제가 생기는 것이 아니다!!  
함수는 데이터 전달받는 역할 뿐 아닌 외부 컴포넌트에 연결될 수 있기에 추가 부작용 또한 내재하고 있다.

외부 컴포넌트 중 하나의 문제로 인한 것을 알 수 있으려면,  
적절하게 인터페이스를 설계함으로써 쉽게 디버깅할 수 있다고 한다.  
함수는 심각한 오류에 대해 명확하게 알려줌으로써 이를 적절하게 해결할 수 있도록 해야 한다.

여기서 필요한 것이 바로 `예외 메커니즘` !!  
- 예외적인 상황을 명확하게 알려주고 원래의 비즈니스 로직에 따라 흐름을 유지  

예외를 사용하여 시나리오 또는 비즈니스 로직을 처리하려고 하면 프로그램의 흐름을 읽기 어려워진다고 한다.  
```
이로 인해 go-to 문 같은 것을 사용하는 경우도 있는데 이는 상황을 악화시킴  
호출 스택의 여러 수준에서 사용되면 논리를 캡슐화 못할 수 있다고 한다  
또한 프로그램이 꼭 처리해야하는 예외적인 비즈니스 로직을 except 블록과 혼합하여 사용하면 더욱 악화시킴  
이렇게 되면 유지보수가 필요한 핵심 논리와 오류를 구별하는 것이 어려워지기 때문  
```

또한 예외란 대개 호출자에게 잘못을 알려주는 것이다.  
예외는 캡슐화를 약화시키기에 꼭 신중하게 사용해야 한다.  
함수에 예외가 많다 = 호출자가 함수에 대해 더 많은 것을 알아야 한다.  
함수에 예외가 많다 = 문맥에서 자유롭지 않다.  

반대로 너무 많은 예외가 나온다는 것은 함수가 응집력이 약하고 너무 많은 책임을 가지고 있다는 신호일 수 있으니  
여러 개의 작은 것으로 나눠야 할 필요가 있을 수 있다.  

---