## 계약에 의한 디자인
소프트웨어는
1. 사용자가 직접 호출하는 경우
2. 코드의 다른 부분에서 호출하는 경우
이렇게 나뉜다.  
두번째의 경우에는 애플리케이션의 책임을 나누어 레이어나 컴포넌트로 분리한 경우에 그러하다.  

#### 컴포넌트
기능을 숨겨 캡슐화하고 함수를 사용할 고객에게 API(Application Programming Interface)를 노출해야 한다.  
컴포넌트의 함수, 클래스, 메서드는 특별한 유의사항에 따라 동작해야 한다.  
그렇지 않을 경우 코드가 깨진다는 것이고, 반대로 호출하는 측에서는 기대한 응답과 다른 경우 함수 호출에 실패하고 결함이 발생한다.

API를 디자인할 때 예상되는 입력, 출력 및 부작용(예외처리?)를 문서화해야 한다.  
하지만 문서화가 런타임 시의 동작을 강제할 수는 없다.  

즉 코드가 정상적으로 동작하기 위해 기대하는 것, 호출자가 반환 받기를 기대하는 것은 디자인의 하나가 되어야 한다.  
여기서 `계약(Contract)`이라는 개념이 생긴다고 한다.  

즉 계약에 의한 디자인(Design by Contract)란 이런 것이라고 한다.  
1. 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약 진행  
2. 계약을 어겼을 경우 명시적으로 왜 계속할 수 예외를 발생시킨다.  

이 책에서 말하는 `계약`이란 소프트웨어 컴포넌트 간의 통신 중 반드시 지켜져야 할 몇가지 규칙을 강제하는 것이다.  
계약은 사전조건, 사후조건을 명시하며 때로는 불변식, 부작용을 기술한다고 한다.  

```
사전조건(precondition): 코드가 실행되기 전에 체크해야 하는 것들.  
함수가 진행되기 전에 체크하는 조건이며 일반적으로 파라미터에 제공된 데이터의 유효성 검사.  
이는 호출자에게 부과된 임무이다.  

사후조건(postconditon): 함수 반환 값의 유효성 검사.  
사후조건 검증은 호출자가 이 컴포넌트에게 기대한 바 응답 받았는지 확인하기 위해 수행.  

불변식(invariant): 함수의 docstring에 불변식에 대해 문서화하는게 때로는 좋다고 한다.  
불변식은 함수가 실행되는 동안 일정하게 유지되는 것으로 함수의 로직에 문제가 없는지 확인하기 위한 것.  

부작용(side-effect): 코드의 부작용을 선택적으로 docstring에 문서화하기도 한다.  
```

위 모든 것들을 문서화해야 하지만 처음 2개인 사전조건과 사후조건만 코드 레벨에서 강제한다고 한다.  
DbC를 하는 이유는 오류가 발생할 때 쉽게 찾아낼 수 있기 때문이다.  
또한 잘못된 가정 하에 코드의 핵심 부분이 실행되는 것을 방지할 수 있기 때문이다.  

단지 어떤 부분에서 실패했다는 에러를 발생시키는 것을 넘어 `책임의 한계`를 명확히 하는데 도움이 된다.  
만약 호출자가 잘못된 인자를 제공했다면 어디를 고칠지 등..  

사전조건은 클라이언트와 연관있고 사후조건은 컴포넌트와 연관되어 있다고 한다.  
컴포넌트는 클라이언트가 확인하고 강제할 수 있는 값을 보장해야 한다.  

사전조건 검증에 실패: 클라이언트의 결함  
사후조건 검증에 실패: 특정 모듈이나 제공 클래스 자체에 결함  

특히 사전조건은 런타임 중에 확인할 수 있다는 점이 있기에 조건에 맞지 않는다면 실행하지 않아야 한다..  
---
### 사전조건(precondition)
사전조건은 함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것  
즉, 적절한 데이터를 전달하는 것  
예) 초기화된 객체, null 이 아닌 값 등의 조건  

파이썬은 동적으로 타입이 결정되므로 전달된 데이터가 적절한 타입인지 확인하는 경우도 있음  
이는 mypy가 하는 타입 체킹과 다르며 `필요로 하는 값이 정확한지` 확인하는 것에 가까움  

함수는 처리할 정보에 대해 적절한 유효성 검사를 해야 함  
그렇다면 유효성 검사를 어디에서 할까?  
1. 클라이언트가 함수를 호출하기 전에 할지
2. 함수가 자체적으로 로직을 실행하기 전에 검사하도록 할지  
전자는 관용적인(tolerant) 접근법: 함수가 어떤 값이라도 수용하기 때문에(깨진 값이라도 우선 받고 봄)  
후자는 까다로운(demanding) 접근법  

책에서는 까다로운 접근법을 사용할 예정이고,  
어떤 방식을 택하든 `중복 제거 원칙`을 기억해야 한다고 한다.  
중복 제거 원칙은 양쪽이 아닌 오직 어느 한쪽에서만 해야 한다고 한다.(클라이언트에 두거나 함수 자체에 두거나)<dry 원칙과 연계됨>

---
### 사후조건(postconditon)
사후조건은 함수나 메서드가 반환된 후의 상태를 강제하는 것이다.  
이들이 적절한 속성으로 호출되었다면(사전조건에 맞다면) 사후조건은 특정 속성이 보존되도록 보장해야 한다.  

사후조건을 사용하여 클라이언트가 필요한 모든 것을 검사할 수 있다.  
메서드가 적절히 실행 -> 계약 이루어짐 -> 사후조건 검증 통과 -> 클라이언트는 반환 객체를 문제 없이 사용할 수 있어야 함  
---

### 파이썬스러운 계약
Programming by Contract for Python이라는 PEP-316은 연기 상태라고 한다.(책을 쓰는 시점)  
하지만 이는 파이썬으로 디자인 원칙을 구현할 수 없다는 뜻은 아니라고 한다.  

함수 및 클래스에 RuntimeError 또는 ValueError 예외를 발생시키는 `제어 메커니즘` 추가  
올바른 예외타입이나 일반적인 규칙을 만드는 것은 앱에 종속적인 부분이 많기에 어렵다고 한다.  
문제를 정확하게 특정하기 어려우면 `사용자 정의 예외`를 만드는 것이 가장 좋다고 한다.  
또한 코드를 가능한 격리된 상태로 유지하는 것이 좋다고 한다.  
1. 사전조건에 대한 검사
2. 사후조건에 대한 검사
3. 핵심 기능에 대한 구현
이 3개를 구분하라는 의미다.  
(더 작은 함수로 쪼갤수도 있지만 데코레이터를 사용하는 것이 대안이 될 것이라고 함)

---

## 결론
디자인 원칙의 주된 가치는 문제가 있는 부분을 효과적으로 식별하는 것.  
계약을 정의함으로써 오류 발생시 코드의 어떤 부분이 손상되었는지, 계약이 파손되었는지 명확히 파악 가능.  

디자인 원칙을 따르면 코드가 견고해지며 구조를 명확히 할 수 있다고 한다.  
즉흥적인 유효성 검사나 모든 실패 시나리오 검증 대신,  
계약은 함수나 메서드가 정상 동작하기 위해 기대하는 것이 무엇인지, 무엇을 기대할 수 있는지 정의한다.  

당연 이 원칙을 따르려면 추가 작업이나 또는 `계약에 의한 단위 테스트`를 추가해야 할 수도 있지만  
품질이 장기적으로 보상되기에 따르는 것이 좋다고 한다.  

이 방법이 효과적이기 위해서는
1. what
2. how
무엇을 어떻게 기꺼이 검증할 것인지 신중이 검토해봐야 한다.  

단순히 함수 파라미터의 `올바른 데이터 타입`만 검사하는 것은 크게 의미 없다고 한다.  
이는 특히 파이썬을 정적 타입 언어로 만드는 것과 비슷하다는 주장도 있다고 한다.  

1. 함수에 전달되는 객체의 속성과 반환 값 검사
2. 이들이 유지해야 하는 조건 확인
등의 작업을 하는 것이 실질적인 가치가 있고 또한 Mypy를 같이 사용하면 효율적이게 이룰 수 있다고 한다.  