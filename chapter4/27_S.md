## 단일 책임 원칙(S)

단일 책임 원칙(Single Responsibility Principle - SRP)은 소프트웨어 컴포넌트 즉 클래스가 단 하나의 책임을 져야한다는 원칙

클래스가 유한이 책임이 있다 -> 하나의 구체적인 일을 담당 -> 변화해야 할 이유는 단 하나 뿐

- 오직 도메인의 문제가 변경될 시 클래스 업데이트
- 다른 이유로 클래스를 수정해야 한다면 추상화가 잘못되어 있다는 것을 의미(너무 많은 책임)

이는 보다 `응집력 있는 추상화`를 하는데 도움이 됨  
(유닉스 철학을 따르는 딱 하나의 일을 하는 객체)

다시 말해 클래스는 작을수록 좋다.  
SRP는 응집력과 밀접한 관련이 있음.

추구하는 것은 클래스에 있는 프로퍼티와 속성이 항상 메서드를 통해서 사용되도록 하는 것

어떤 면에서는 관계형 데이터베이스 설계에서 정규화 개념과 유사  
만약 객체의 속성이나 메서드의 특성이 다른 그룹에서 발견되면 이들을 다른 곳으로 옮겨야 함

즉, 클래스의 메서드는 `상호 배타적`이며 `서로 관련이 없어야 하고` 이들은 서로 다른 책임을 가지고 있으므로 `더 작은 클래스로 분해`할 수 있어야 한다.

### 너무 많은 책임을 가진 클래스

예제: 로그 파일이나 데이터베이스 같은 소스에서 이벤트의 정보를 읽어서 로그별로 필요한 액션을 분류하는 애플리케이션

#### SRP를 준수하지 않은 디자인
```
class SystemMonitor:
    def load_activity(self):
        """ 소스에서 처리할 이벤트를 가져오기 """
    
    def idntify_events(self):
        """ 가져온 데이터를 파싱하여 도메인 객체 이벤트로 변환 """
    
    def stream_events(self):
        """ 파싱한 이벤트를 외부 에이전트로 전송 """
```  
위 클래스의 문제점은 독립적인 동작을 하는 메서드를 하나의 인터페이스에 정의했다는 것이다.  
이 디자인 결함은 유지보수를 어렵게하고 오류가 발생하기 쉽게 만든다.  
이 예제에서 각 메서드는 클래스의 책임을 대표하며 각각의 책임마다 수정 사유가 발생한다.  
(메서드마다 다양한 변경의 필요성)  

특정 소스에서 정보를 가져온 로더(loader) 메서드의 경우  
분명한 것은 로더가 자체적인 절차를 갖게 될 것이라는 것이다.  
1. 데이터 소스에 연결
2. 데이터 로드
3. 예상된 형식으로 파싱  
만약 데이터 구조를 바꾸는 등의 이유로 이 중에 어떤 것이라도 수정해야 한다면 SystemMonitor 클래스를 변경해야 한다.  

단순 데이터의 표현이 변경되었다고 해서 SystemMonitor 객체를 변경해서는 안된다.  

동일하게 나머지 두개의 메서드의 경우에도 이벤트를 인식하는 방법이나 전잘하는 방법을 변경하면 마찬가지로 클래스를 변경해야 한다.  

외부 요소에 의한 영향을 최소화 하고 싶을 때 해결책은 보다 작고 응집력 있는 추상화를 하는 것이다.  


### 책임 분산
각자의 책임을 가진 열 객체로 만들고, 이들 객체들과 협력함으로써 동일한 기능을 구현 가능하다.  
```
class AlertSystem:
    def run(self):

class ActivityReader(AlertSystem):
    def load(self):

class SystemMonitor(AlertSystem):
    def identify_event(self):

class Output(AlertSystem):
    def stream(self):
```  
데이터 소스에서 이벤트를 로드하는 방법을 변경해도 AlertSystem은 이러한 변경 사항과는 관련 없고 SystemMonitor는 아무 것도 수정하지 않아도 된다.(Output도 마찬가지)  
변경 사항이 로컬에만 적용되고 영향이 미미하므로 각 클래스의 유지보수가 쉽다.  

새로운 클래스는 유지보수뿐 아닌 재사용이 쉬운 인터페이스를 정의한다.  
예를 들어 앱의 다른 부분에서 로그를 다른 용도로 읽어야 한다는 가정이라면,  
이 디자인을 적용하면 ActivityReader 타입의 객체를 사용하면 된다.  
이전 디자인에서는 전혀 필요하지 않은 idntify_events, stream_events 메서드도 같이 상속 받았기에 이치에 맞지 않지만, 이제는 필요한 메서드만 상속을 받기 때문에 이치에 맞다.  

그러나 각 클래스가 딱 하나의 메서드를 가져야 한다는 것을 뜻하는 것은 아니다.  
처리해야할 로직이 같은 경우 하나의 클래스에 여러 메서드를 추가할 수 있다.  