### 데코레이터 활용 사례

- 파라미터 변환
- 코드 추적
- 파라미터 유효성 검사
- 재시도 로직 구현
- 일부 반복 작업을 데코레이터로 이동하여 클래스 단순화

### 데코레이터 활용시 흔한 실수 피하기
- 래핑된 원본 객체의 데이터 보존: wrapped 함수에 @wraps 데코레이터를 적용하여 실제로는 function 파라미터 함수를 래핑한 것을 알려주기
- 데코레이터 부작용 처리: 래핑된 함수 내부로 코드를 이동
- 데코레이터 부작용의 활용: 공용 레지스트리에 객체 등록하는 경우

### 데코레이터와 DRY 원칙
- 데코레이터의 가장 큰 강점은 여러 객체에 데코레이터를 적용하여 **코드를 재사용**할 수 있다는 것
- 하지만 데코레이터는 코드의 복잡성을 증가시키키에, 복잡성과 재사용성의 trade-off를 잘 고려해야 함
1. 처음부터 데코레이터를 만들지 않는다. 패턴이 생기고 데코레이터에 대한 추상화가 명확해지면 그때 리팩토링 한다.
2. 데코레이터가 적어도 3회 이상 필요한 경우에 구현한다. = 소프트웨어 공학 GLASS 01
3. 데코레이터 코드를 최소한으로 유지한다.

### 좋은 데코레이터의 특성
- 캡슐화와 관심사의 분리:  
  실제로 하는 일과 데코레이팅하는 일의 책임을 명확하게 구분.  
  데코레이터의 클라이언트는 내부에서 어떻게 구현했는지 전혀 알 수 없는 블랙박스 모드로 동작해야 함
- 독립성:  
  데코레이터가 하는 일은 독립적이어야 하고 데코레이팅되는 객체와 최대한 분리되어야 함
- 재사용성:  
  데코레이터는 하나의 함수 인스턴스가 아닌 여러 유형에 적용 가능한 형태가 바람직하다.  
  하나의 함수에만 적용된다면 굳이 데코레이터가 아닌 함수로 대신할 수 있기 때문이다.  
  즉 충분히 범용적이어야 함